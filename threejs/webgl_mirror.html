<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - mirror</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #888888;
				font-family:Monospace;
				font-size:13px;

				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			a {
				color: #00f;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		</div>

		<script src="js/vendor/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>

		<script>

			// scene size
			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;

			// camera
			var VIEW_ANGLE = 45;
			var ASPECT = WIDTH / HEIGHT;
			var NEAR = 1;
			var FAR = 500;

			var camera, scene, renderer;

			var cameraControls;

			function init() {

				// renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
				camera.position.set( 0, 75, 160 );

				cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
				cameraControls.target.set( 0, 40, 0);
				cameraControls.maxDistance = 400;
				cameraControls.minDistance = 10;
				cameraControls.update();

				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

			}

			function drawLine() {
				var material = new THREE.LineBasicMaterial({ color: 0x0000ff });
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3(-20, 0, 0));
				geometry.vertices.push(new THREE.Vector3(0, 0, 0));
				geometry.vertices.push(new THREE.Vector3(20, 0, 0));
				
				return new THREE.Line(geometry, material);
			}
			
			var line;
			function render() {
				
				line = drawLine();
				scene.add(line);

				renderer.render(scene, camera);

			}
			

			function update() {

				requestAnimationFrame( update );

				// var timer = Date.now() * 0.01;
				
				
				// sphereGroup.rotation.y -= 0.002;

				// smallSphere.position.set(
				// 	Math.cos( timer * 0.1 ) * 30,
				// 	Math.abs( Math.cos( timer * 0.2 ) ) * 20 + 5,
				// 	Math.sin( timer * 0.1 ) * 30
				// );
				// smallSphere.rotation.y = ( Math.PI / 2 ) - timer * 0.1;
				// smallSphere.rotation.z = timer * 0.8;

				cameraControls.update();

				render();
			}

			init();
			update();

		</script>
	</body>
</html>
